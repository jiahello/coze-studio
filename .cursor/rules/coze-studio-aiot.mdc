---
description: This file provides guidance to cursor when working with code in this repository.
alwaysApply: false
---

# coze-studio-aiot.md

This file provides guidance to cursor when working with code in this repository.

## Project Overview

Coze Studio is an all-in-one AI agent development platform with both frontend (React + TypeScript) and backend (Go) components. The project uses a sophisticated monorepo architecture managed by Rush.js with 135+ frontend packages organized in a hierarchical dependency system.

IoT/语音整合：Coze Studio 已引入物联网与智能语音的基础设施（数据库新增四表、NSQ 主题/消费组与可配置开关 `ENABLE_IOT_VOICE`、统一消息契约与后端接入点、前端 TTS/硬件入口）。详细说明见下文“IoT 与智能语音集成（PR #1）”。

## Development Commands

### Environment Setup

```bash
# Clone and setup
git clone https://github.com/coze-dev/coze-studio.git
cd coze-studio

# Install frontend dependencies
rush update

# For Docker-based development
cd docker
cp .env.example .env
# Configure model settings in backend/conf/model/
docker compose up -d
# Access at http://localhost:8888
```

### Development Workflow

```bash
# Start middleware services (MySQL, Redis, Elasticsearch, etc.)
make middleware

# Start Go backend in development mode
make server

# Start frontend development server
cd frontend/apps/coze-studio
npm run dev

# Full development environment
make debug
```

### Build Commands

```bash
# Build frontend only
make fe

# Build Go server
make build_server

# Build everything with Docker
make web

# Rush monorepo commands
rush build                    # Build all packages
rush rebuild -o @coze-studio/app  # Build specific package
rush test                     # Run all tests
rush lint                     # Lint all packages
```

### Testing

```bash
# Run tests (Vitest-based)
rush test
npm run test                  # In specific package
npm run test:cov             # With coverage

# Backend tests
cd backend && go test ./...
```

## Architecture Overview

### Frontend Architecture

- **Monorepo**: Rush.js with 135+ packages across 4 dependency levels
- **Build System**: Rsbuild (Rspack-based) for fast builds
- **UI Framework**: React 18 + TypeScript + Semi Design + Tailwind CSS
- **State Management**: Zustand for global state
- **Package Organization**:
  - `arch/`: Core infrastructure (level-1)
  - `common/`: Shared components and utilities (level-2)
  - `agent-ide/`, `workflow/`, `studio/`: Feature domains (level-3)
  - `apps/coze-studio`: Main application (level-4)

### Backend Architecture (Go)

- **Framework**: Hertz HTTP framework
- **Architecture**: Domain-Driven Design (DDD) with microservices
- **Structure**:
  - `domain/`: Business logic and entities
  - `application/`: Application services and use cases
  - `api/`: HTTP handlers and routing
  - `infra/`: Infrastructure implementations
  - `crossdomain/`: Cross-cutting concerns

### Key Architectural Patterns

- **Adapter Pattern**: Extensive use for loose coupling between layers
- **Interface Segregation**: Clear contracts between domains
- **Event-Driven**: NSQ message queue for async communication
- **API-First**: Comprehensive OpenAPI specifications

## Database & Infrastructure

### Docker Services Stack

- **Database**: MySQL 8.4.5
- **Cache**: Redis 8.0
- **Search**: Elasticsearch 8.18.0 with SmartCN analyzer
- **Vector DB**: Milvus v2.5.10 for embeddings
- **Storage**: MinIO for object storage
- **Message Queue**: NSQ (nsqlookupd, nsqd, nsqadmin)
- **Configuration**: etcd 3.5

### Database Management

```bash
# Sync database schema
make sync_db

# Dump database schema
make dump_db

# Initialize SQL data
make sql_init

# Atlas migration management
make atlas-hash
```

## Key Development Patterns

### Frontend Package Development

- Each package follows consistent structure with `README.md`, `package.json`, `tsconfig.json`, `eslint.config.js`
- Adapter pattern extensively used for decoupling (e.g., `-adapter` suffix packages)
- Base/Core pattern for shared functionality (e.g., `-base` suffix packages)
- Use workspace references (`workspace:*`) for internal dependencies

### Backend Development

- Follow DDD principles with clear domain boundaries
- Use dependency injection via interfaces
- Implement proper error handling with custom error types
- Write comprehensive tests for domain logic

### Model Configuration

Before deployment, configure AI models in `backend/conf/model/`:

1. Copy template from `backend/conf/model/template/`
2. Set `id`, `meta.conn_config.api_key`, and `meta.conn_config.model`
3. Supported providers: OpenAI, Volcengine Ark, Claude, Gemini, Qwen, DeepSeek, Ollama

## IoT 与智能语音集成（PR #1）

本节梳理“feat(iot): 添加物联网与智能语音基础设施”所引入的核心能力，涵盖数据库 Schema、消息队列、后端接入点与前端路由，以便在后续 API/UI 开发中复用并保持解耦。

### 数据库 Schema（Atlas 迁移）

- 新增四张表（与现有 Atlas 迁移体系兼容）：
  - `hardware_device`: AI 硬件设备管理（空间维度唯一约束、心跳时间、配对验证码等）
  - `tts_voice`: TTS 音色库（系统级/空间级，可扩展属性如语言、情感能力、采样率等）
  - `app_tts_settings`: 应用级 TTS 设置（每 App 唯一）
  - `hardware_tts_settings`: 设备级 TTS 设置（设备优先，覆盖 App 设置）
- 迁移文件：`docker/atlas/migrations/20250809123000_add_iot_tts.sql`
- 同步与校验：使用上文的 Atlas 命令（如 `make atlas-hash`、`make sync_db`）。

### 消息队列（NSQ/Kafka/RMQ 抽象）

- 主题（Topic）：
  - `opencoze_iot_device_inbound` / `opencoze_iot_device_outbound`
  - `opencoze_iot_llm_tasks` / `opencoze_iot_llm_results`
  - `opencoze_iot_tts_tasks` / `opencoze_iot_tts_results`
- 消费组（Group）：`cg_iot`、`cg_llm`、`cg_tts`（详见 `backend/types/consts/consts.go`）
- 环境变量：
  - `ENABLE_IOT_VOICE=1` 开启 IoT/语音总线
  - `COZE_MQ_TYPE=nsq` 选择 MQ 类型
  - `MQ_NAME_SERVER=nsqd:4150` 指向 NSQD（或使用 `MQ_NSQ_LOOKUPD`）
- Docker 组件（已在栈中）：`nsqlookupd`、`nsqd`、`nsqadmin`（见 `docker/docker-compose.yml`）。

### 后端接入点与消息契约

- 初始化与总线接线：`backend/application/iot/init.go`
  - 注册消费者：`device_inbound`、`llm_tasks/results`、`tts_results`
  - 生产者：`device_outbound`、`llm_tasks/results`、`tts_tasks`
- 统一消息封装与类型：`backend/infra/contract/iot/message.go`
  - 典型类型：`llm.request`、`llm.task`、`llm.result`、`tts.request`、`tts.result` 等
- 应用启动挂载：`backend/application/application.go`（受 `ENABLE_IOT_VOICE` 控制）
- 相关环境常量：`backend/types/consts/consts.go`

### REST API（当前可用）

- 设备（Device）
  - POST `/api/iot/devices/list` { space_id, page, page_size, keyword }
  - POST `/api/iot/devices/upsert` { id?, space_id, device_id, name, app_id?, status? }
  - GET `/api/iot/devices/tts/get?device_id=...&app_id=...`
  - POST `/api/iot/devices/tts/set` { device_id, provider, model, voice }
- TTS 音色与预听
  - POST `/api/tts/voices/list` { space_id?, provider?, language?, gender?, page, page_size }
  - POST `/api/tts/preview` { provider, model, voice, text, space_id? }
- 参考实现：`backend/api/handler/coze/iot_service.go`、`backend/application/iotadmin/`

### 前端能力入口

- 路由：`frontend/apps/coze-studio/src/routes/index.tsx` 下的 `path: 'tts'`
- 页面：
  - `frontend/apps/coze-studio/src/pages/tts.tsx`（系统/空间音色列表、应用级 TTS 选择与保存）
  - `frontend/apps/coze-studio/src/pages/hardware.tsx`（设备列表与增改）
  - `frontend/apps/coze-studio/src/pages/hardware-detail.tsx`（设备级 TTS 设置与预听）
- 事件上报（TTS 相关）：`frontend/packages/arch/report-events/src/interaction-event.ts`

### 最小化联通校验（本地）

1. 迁移数据库：`make sync_db`
2. 启动 MQ：Docker 中启用 NSQ 组件；设置 `COZE_MQ_TYPE=nsq` 与 `MQ_NAME_SERVER=nsqd:4150`
3. 启用总线：设置 `ENABLE_IOT_VOICE=1` 后启动后端
4. 访问前端：在 `TTS` 与 `硬件` 页面进行 TTS 选择与设备配置，使用预听验证音色拉取

## Testing Strategy

### Coverage Requirements by Package Level

- **Level 1**: 80% coverage, 90% increment
- **Level 2**: 30% coverage, 60% increment
- **Level 3-4**: 0% coverage (flexible)

### Testing Framework

- **Frontend**: Vitest for unit/integration tests
- **Backend**: Go's built-in testing framework
- **E2E**: Separate e2e subspace configuration

## Common Issues & Solutions

### Frontend Development

- Use `rush update` instead of `npm install` at root level
- Build packages in dependency order using `rush build`
- For hot reload issues, check Rsbuild configuration in specific package

### Backend Development

- Ensure middleware services are running (`make middleware`)
- Check database connectivity and schema sync
- Verify model configurations are properly set

### Docker Issues

- Ensure sufficient resources (minimum 2 Core, 4GB RAM)
- Check port conflicts (8888 for frontend, various for services)
- Use `make clean` to reset Docker volumes if needed

## IDL and Code Generation

The project uses Interface Definition Language (IDL) for API contract management:

- IDL files in `idl/` directory (Thrift format)
- Frontend code generation via `@coze-arch/idl2ts-*` packages
- Backend uses generated Go structs

## Plugin Development

For custom plugin development:

- Reference templates in `backend/conf/plugin/pluginproduct/`
- Follow OAuth schema in `backend/conf/plugin/common/oauth_schema.json`
- Configure authentication keys for third-party services

## Contributing

- Use conventional commits via `rush commit`
- Run linting with `rush lint-staged` (pre-commit hook)
- Ensure tests pass before submitting PRs
- Follow team-based package organization and tagging conventions
